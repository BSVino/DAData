// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: data.proto

#ifndef PROTOBUF_data_2eproto__INCLUDED
#define PROTOBUF_data_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "math.pb.h"
// @@protoc_insertion_point(includes)

namespace da {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_data_2eproto();
void protobuf_AssignDesc_data_2eproto();
void protobuf_ShutdownFile_data_2eproto();

class GameData;
class PlayerPositions;
class VoteResult;
class PlayerInfo;
class KillInfo;
class PlayerList;
class ServerReply;

enum KillFlags {
  KILL_THIRDPERSON = 0,
  KILL_AIMIN = 1,
  KILL_DIVING = 2,
  KILL_ROLLING = 3,
  KILL_SLIDING = 4,
  KILL_FLIPPING = 5,
  KILL_SUPERFALLING = 6,
  KILL_BY_GRENADE = 7,
  KILL_BY_BRAWL = 8,
  KILL_SKILL_ACTIVE = 9,
  KILL_SUPER_SKILL_ACTIVE = 10,
  KILL_IS_TARGET = 11,
  KILL_HAS_BRIEFCASE = 12,
  KILL_IS_BOT = 13,
  KILL_IS_SUICIDE = 14
};
bool KillFlags_IsValid(int value);
const KillFlags KillFlags_MIN = KILL_THIRDPERSON;
const KillFlags KillFlags_MAX = KILL_IS_SUICIDE;
const int KillFlags_ARRAYSIZE = KillFlags_MAX + 1;

const ::google::protobuf::EnumDescriptor* KillFlags_descriptor();
inline const ::std::string& KillFlags_Name(KillFlags value) {
  return ::google::protobuf::internal::NameOfEnum(
    KillFlags_descriptor(), value);
}
inline bool KillFlags_Parse(
    const ::std::string& name, KillFlags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KillFlags>(
    KillFlags_descriptor(), name, value);
}
// ===================================================================

class GameData : public ::google::protobuf::Message {
 public:
  GameData();
  virtual ~GameData();

  GameData(const GameData& from);

  inline GameData& operator=(const GameData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameData& default_instance();

  void Swap(GameData* other);

  // implements Message ----------------------------------------------

  GameData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameData& from);
  void MergeFrom(const GameData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool debug = 1;
  inline bool has_debug() const;
  inline void clear_debug();
  static const int kDebugFieldNumber = 1;
  inline bool debug() const;
  inline void set_debug(bool value);

  // optional string map_name = 2;
  inline bool has_map_name() const;
  inline void clear_map_name();
  static const int kMapNameFieldNumber = 2;
  inline const ::std::string& map_name() const;
  inline void set_map_name(const ::std::string& value);
  inline void set_map_name(const char* value);
  inline void set_map_name(const char* value, size_t size);
  inline ::std::string* mutable_map_name();
  inline ::std::string* release_map_name();
  inline void set_allocated_map_name(::std::string* map_name);

  // optional string server_name = 3;
  inline bool has_server_name() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 3;
  inline const ::std::string& server_name() const;
  inline void set_server_name(const ::std::string& value);
  inline void set_server_name(const char* value);
  inline void set_server_name(const char* value, size_t size);
  inline ::std::string* mutable_server_name();
  inline ::std::string* release_server_name();
  inline void set_allocated_server_name(::std::string* server_name);

  // optional int32 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // optional .da.protobuf.PlayerPositions positions = 5;
  inline bool has_positions() const;
  inline void clear_positions();
  static const int kPositionsFieldNumber = 5;
  inline const ::da::protobuf::PlayerPositions& positions() const;
  inline ::da::protobuf::PlayerPositions* mutable_positions();
  inline ::da::protobuf::PlayerPositions* release_positions();
  inline void set_allocated_positions(::da::protobuf::PlayerPositions* positions);

  // optional bool cheats = 6;
  inline bool has_cheats() const;
  inline void clear_cheats();
  static const int kCheatsFieldNumber = 6;
  inline bool cheats() const;
  inline void set_cheats(bool value);

  // optional .da.protobuf.PlayerPositions kills = 7;
  inline bool has_kills() const;
  inline void clear_kills();
  static const int kKillsFieldNumber = 7;
  inline const ::da::protobuf::PlayerPositions& kills() const;
  inline ::da::protobuf::PlayerPositions* mutable_kills();
  inline ::da::protobuf::PlayerPositions* release_kills();
  inline void set_allocated_kills(::da::protobuf::PlayerPositions* kills);

  // optional .da.protobuf.PlayerPositions deaths = 8;
  inline bool has_deaths() const;
  inline void clear_deaths();
  static const int kDeathsFieldNumber = 8;
  inline const ::da::protobuf::PlayerPositions& deaths() const;
  inline ::da::protobuf::PlayerPositions* mutable_deaths();
  inline ::da::protobuf::PlayerPositions* release_deaths();
  inline void set_allocated_deaths(::da::protobuf::PlayerPositions* deaths);

  // optional int32 connections = 9;
  inline bool has_connections() const;
  inline void clear_connections();
  static const int kConnectionsFieldNumber = 9;
  inline ::google::protobuf::int32 connections() const;
  inline void set_connections(::google::protobuf::int32 value);

  // optional bool teamplay = 10;
  inline bool has_teamplay() const;
  inline void clear_teamplay();
  static const int kTeamplayFieldNumber = 10;
  inline bool teamplay() const;
  inline void set_teamplay(bool value);

  // optional int32 thirdperson_active = 11;
  inline bool has_thirdperson_active() const;
  inline void clear_thirdperson_active();
  static const int kThirdpersonActiveFieldNumber = 11;
  inline ::google::protobuf::int32 thirdperson_active() const;
  inline void set_thirdperson_active(::google::protobuf::int32 value);

  // optional int32 thirdperson_inactive = 12;
  inline bool has_thirdperson_inactive() const;
  inline void clear_thirdperson_inactive();
  static const int kThirdpersonInactiveFieldNumber = 12;
  inline ::google::protobuf::int32 thirdperson_inactive() const;
  inline void set_thirdperson_inactive(::google::protobuf::int32 value);

  // optional int32 disconnections = 13;
  inline bool has_disconnections() const;
  inline void clear_disconnections();
  static const int kDisconnectionsFieldNumber = 13;
  inline ::google::protobuf::int32 disconnections() const;
  inline void set_disconnections(::google::protobuf::int32 value);

  // optional int32 unique_players_this_map = 14;
  inline bool has_unique_players_this_map() const;
  inline void clear_unique_players_this_map();
  static const int kUniquePlayersThisMapFieldNumber = 14;
  inline ::google::protobuf::int32 unique_players_this_map() const;
  inline void set_unique_players_this_map(::google::protobuf::int32 value);

  // optional int32 da_version = 15;
  inline bool has_da_version() const;
  inline void clear_da_version();
  static const int kDaVersionFieldNumber = 15;
  inline ::google::protobuf::int32 da_version() const;
  inline void set_da_version(::google::protobuf::int32 value);

  // repeated string characters_chosen = 16;
  inline int characters_chosen_size() const;
  inline void clear_characters_chosen();
  static const int kCharactersChosenFieldNumber = 16;
  inline const ::std::string& characters_chosen(int index) const;
  inline ::std::string* mutable_characters_chosen(int index);
  inline void set_characters_chosen(int index, const ::std::string& value);
  inline void set_characters_chosen(int index, const char* value);
  inline void set_characters_chosen(int index, const char* value, size_t size);
  inline ::std::string* add_characters_chosen();
  inline void add_characters_chosen(const ::std::string& value);
  inline void add_characters_chosen(const char* value);
  inline void add_characters_chosen(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& characters_chosen() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_characters_chosen();

  // repeated int32 weapons_chosen = 17;
  inline int weapons_chosen_size() const;
  inline void clear_weapons_chosen();
  static const int kWeaponsChosenFieldNumber = 17;
  inline ::google::protobuf::int32 weapons_chosen(int index) const;
  inline void set_weapons_chosen(int index, ::google::protobuf::int32 value);
  inline void add_weapons_chosen(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      weapons_chosen() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_weapons_chosen();

  // repeated int32 skills_chosen = 18;
  inline int skills_chosen_size() const;
  inline void clear_skills_chosen();
  static const int kSkillsChosenFieldNumber = 18;
  inline ::google::protobuf::int32 skills_chosen(int index) const;
  inline void set_skills_chosen(int index, ::google::protobuf::int32 value);
  inline void add_skills_chosen(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      skills_chosen() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_skills_chosen();

  // repeated .da.protobuf.VoteResult votes = 19;
  inline int votes_size() const;
  inline void clear_votes();
  static const int kVotesFieldNumber = 19;
  inline const ::da::protobuf::VoteResult& votes(int index) const;
  inline ::da::protobuf::VoteResult* mutable_votes(int index);
  inline ::da::protobuf::VoteResult* add_votes();
  inline const ::google::protobuf::RepeatedPtrField< ::da::protobuf::VoteResult >&
      votes() const;
  inline ::google::protobuf::RepeatedPtrField< ::da::protobuf::VoteResult >*
      mutable_votes();

  // repeated string weapons_chosen_s = 20;
  inline int weapons_chosen_s_size() const;
  inline void clear_weapons_chosen_s();
  static const int kWeaponsChosenSFieldNumber = 20;
  inline const ::std::string& weapons_chosen_s(int index) const;
  inline ::std::string* mutable_weapons_chosen_s(int index);
  inline void set_weapons_chosen_s(int index, const ::std::string& value);
  inline void set_weapons_chosen_s(int index, const char* value);
  inline void set_weapons_chosen_s(int index, const char* value, size_t size);
  inline ::std::string* add_weapons_chosen_s();
  inline void add_weapons_chosen_s(const ::std::string& value);
  inline void add_weapons_chosen_s(const char* value);
  inline void add_weapons_chosen_s(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& weapons_chosen_s() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_weapons_chosen_s();

  // repeated string skills_chosen_s = 21;
  inline int skills_chosen_s_size() const;
  inline void clear_skills_chosen_s();
  static const int kSkillsChosenSFieldNumber = 21;
  inline const ::std::string& skills_chosen_s(int index) const;
  inline ::std::string* mutable_skills_chosen_s(int index);
  inline void set_skills_chosen_s(int index, const ::std::string& value);
  inline void set_skills_chosen_s(int index, const char* value);
  inline void set_skills_chosen_s(int index, const char* value, size_t size);
  inline ::std::string* add_skills_chosen_s();
  inline void add_skills_chosen_s(const ::std::string& value);
  inline void add_skills_chosen_s(const char* value);
  inline void add_skills_chosen_s(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& skills_chosen_s() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_skills_chosen_s();

  // optional float map_time = 22;
  inline bool has_map_time() const;
  inline void clear_map_time();
  static const int kMapTimeFieldNumber = 22;
  inline float map_time() const;
  inline void set_map_time(float value);

  // optional int32 vr_active = 23;
  inline bool has_vr_active() const;
  inline void clear_vr_active();
  static const int kVrActiveFieldNumber = 23;
  inline ::google::protobuf::int32 vr_active() const;
  inline void set_vr_active(::google::protobuf::int32 value);

  // optional int32 vr_inactive = 24;
  inline bool has_vr_inactive() const;
  inline void clear_vr_inactive();
  static const int kVrInactiveFieldNumber = 24;
  inline ::google::protobuf::int32 vr_inactive() const;
  inline void set_vr_inactive(::google::protobuf::int32 value);

  // optional int32 platform_windows = 25;
  inline bool has_platform_windows() const;
  inline void clear_platform_windows();
  static const int kPlatformWindowsFieldNumber = 25;
  inline ::google::protobuf::int32 platform_windows() const;
  inline void set_platform_windows(::google::protobuf::int32 value);

  // optional int32 platform_linux = 26;
  inline bool has_platform_linux() const;
  inline void clear_platform_linux();
  static const int kPlatformLinuxFieldNumber = 26;
  inline ::google::protobuf::int32 platform_linux() const;
  inline void set_platform_linux(::google::protobuf::int32 value);

  // optional int32 platform_osx = 27;
  inline bool has_platform_osx() const;
  inline void clear_platform_osx();
  static const int kPlatformOsxFieldNumber = 27;
  inline ::google::protobuf::int32 platform_osx() const;
  inline void set_platform_osx(::google::protobuf::int32 value);

  // repeated .da.protobuf.KillInfo kill_details = 28;
  inline int kill_details_size() const;
  inline void clear_kill_details();
  static const int kKillDetailsFieldNumber = 28;
  inline const ::da::protobuf::KillInfo& kill_details(int index) const;
  inline ::da::protobuf::KillInfo* mutable_kill_details(int index);
  inline ::da::protobuf::KillInfo* add_kill_details();
  inline const ::google::protobuf::RepeatedPtrField< ::da::protobuf::KillInfo >&
      kill_details() const;
  inline ::google::protobuf::RepeatedPtrField< ::da::protobuf::KillInfo >*
      mutable_kill_details();

  // repeated .da.protobuf.PlayerList player_list = 29;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 29;
  inline const ::da::protobuf::PlayerList& player_list(int index) const;
  inline ::da::protobuf::PlayerList* mutable_player_list(int index);
  inline ::da::protobuf::PlayerList* add_player_list();
  inline const ::google::protobuf::RepeatedPtrField< ::da::protobuf::PlayerList >&
      player_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::da::protobuf::PlayerList >*
      mutable_player_list();

  // @@protoc_insertion_point(class_scope:da.protobuf.GameData)
 private:
  inline void set_has_debug();
  inline void clear_has_debug();
  inline void set_has_map_name();
  inline void clear_has_map_name();
  inline void set_has_server_name();
  inline void clear_has_server_name();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_positions();
  inline void clear_has_positions();
  inline void set_has_cheats();
  inline void clear_has_cheats();
  inline void set_has_kills();
  inline void clear_has_kills();
  inline void set_has_deaths();
  inline void clear_has_deaths();
  inline void set_has_connections();
  inline void clear_has_connections();
  inline void set_has_teamplay();
  inline void clear_has_teamplay();
  inline void set_has_thirdperson_active();
  inline void clear_has_thirdperson_active();
  inline void set_has_thirdperson_inactive();
  inline void clear_has_thirdperson_inactive();
  inline void set_has_disconnections();
  inline void clear_has_disconnections();
  inline void set_has_unique_players_this_map();
  inline void clear_has_unique_players_this_map();
  inline void set_has_da_version();
  inline void clear_has_da_version();
  inline void set_has_map_time();
  inline void clear_has_map_time();
  inline void set_has_vr_active();
  inline void clear_has_vr_active();
  inline void set_has_vr_inactive();
  inline void clear_has_vr_inactive();
  inline void set_has_platform_windows();
  inline void clear_has_platform_windows();
  inline void set_has_platform_linux();
  inline void clear_has_platform_linux();
  inline void set_has_platform_osx();
  inline void clear_has_platform_osx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* map_name_;
  ::std::string* server_name_;
  ::da::protobuf::PlayerPositions* positions_;
  ::google::protobuf::int32 timestamp_;
  bool debug_;
  bool cheats_;
  bool teamplay_;
  ::da::protobuf::PlayerPositions* kills_;
  ::da::protobuf::PlayerPositions* deaths_;
  ::google::protobuf::int32 connections_;
  ::google::protobuf::int32 thirdperson_active_;
  ::google::protobuf::int32 thirdperson_inactive_;
  ::google::protobuf::int32 disconnections_;
  ::google::protobuf::int32 unique_players_this_map_;
  ::google::protobuf::int32 da_version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> characters_chosen_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > weapons_chosen_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > skills_chosen_;
  ::google::protobuf::RepeatedPtrField< ::da::protobuf::VoteResult > votes_;
  ::google::protobuf::RepeatedPtrField< ::std::string> weapons_chosen_s_;
  ::google::protobuf::RepeatedPtrField< ::std::string> skills_chosen_s_;
  float map_time_;
  ::google::protobuf::int32 vr_active_;
  ::google::protobuf::int32 vr_inactive_;
  ::google::protobuf::int32 platform_windows_;
  ::google::protobuf::int32 platform_linux_;
  ::google::protobuf::int32 platform_osx_;
  ::google::protobuf::RepeatedPtrField< ::da::protobuf::KillInfo > kill_details_;
  ::google::protobuf::RepeatedPtrField< ::da::protobuf::PlayerList > player_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(29 + 31) / 32];

  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();

  void InitAsDefaultInstance();
  static GameData* default_instance_;
};
// -------------------------------------------------------------------

class PlayerPositions : public ::google::protobuf::Message {
 public:
  PlayerPositions();
  virtual ~PlayerPositions();

  PlayerPositions(const PlayerPositions& from);

  inline PlayerPositions& operator=(const PlayerPositions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerPositions& default_instance();

  void Swap(PlayerPositions* other);

  // implements Message ----------------------------------------------

  PlayerPositions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerPositions& from);
  void MergeFrom(const PlayerPositions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .da.protobuf.Vector position = 1;
  inline int position_size() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::da::protobuf::Vector& position(int index) const;
  inline ::da::protobuf::Vector* mutable_position(int index);
  inline ::da::protobuf::Vector* add_position();
  inline const ::google::protobuf::RepeatedPtrField< ::da::protobuf::Vector >&
      position() const;
  inline ::google::protobuf::RepeatedPtrField< ::da::protobuf::Vector >*
      mutable_position();

  // @@protoc_insertion_point(class_scope:da.protobuf.PlayerPositions)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::da::protobuf::Vector > position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();

  void InitAsDefaultInstance();
  static PlayerPositions* default_instance_;
};
// -------------------------------------------------------------------

class VoteResult : public ::google::protobuf::Message {
 public:
  VoteResult();
  virtual ~VoteResult();

  VoteResult(const VoteResult& from);

  inline VoteResult& operator=(const VoteResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VoteResult& default_instance();

  void Swap(VoteResult* other);

  // implements Message ----------------------------------------------

  VoteResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VoteResult& from);
  void MergeFrom(const VoteResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string issue = 1;
  inline bool has_issue() const;
  inline void clear_issue();
  static const int kIssueFieldNumber = 1;
  inline const ::std::string& issue() const;
  inline void set_issue(const ::std::string& value);
  inline void set_issue(const char* value);
  inline void set_issue(const char* value, size_t size);
  inline ::std::string* mutable_issue();
  inline ::std::string* release_issue();
  inline void set_allocated_issue(::std::string* issue);

  // optional string details = 2;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 2;
  inline const ::std::string& details() const;
  inline void set_details(const ::std::string& value);
  inline void set_details(const char* value);
  inline void set_details(const char* value, size_t size);
  inline ::std::string* mutable_details();
  inline ::std::string* release_details();
  inline void set_allocated_details(::std::string* details);

  // optional bool result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline bool result() const;
  inline void set_result(bool value);

  // @@protoc_insertion_point(class_scope:da.protobuf.VoteResult)
 private:
  inline void set_has_issue();
  inline void clear_has_issue();
  inline void set_has_details();
  inline void clear_has_details();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* issue_;
  ::std::string* details_;
  bool result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();

  void InitAsDefaultInstance();
  static VoteResult* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInfo : public ::google::protobuf::Message {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfo& default_instance();

  void Swap(PlayerInfo* other);

  // implements Message ----------------------------------------------

  PlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .da.protobuf.Vector position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::da::protobuf::Vector& position() const;
  inline ::da::protobuf::Vector* mutable_position();
  inline ::da::protobuf::Vector* release_position();
  inline void set_allocated_position(::da::protobuf::Vector* position);

  // optional int32 health = 2;
  inline bool has_health() const;
  inline void clear_health();
  static const int kHealthFieldNumber = 2;
  inline ::google::protobuf::int32 health() const;
  inline void set_health(::google::protobuf::int32 value);

  // optional uint64 flags = 3;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 3;
  inline ::google::protobuf::uint64 flags() const;
  inline void set_flags(::google::protobuf::uint64 value);

  // optional string weapon = 4;
  inline bool has_weapon() const;
  inline void clear_weapon();
  static const int kWeaponFieldNumber = 4;
  inline const ::std::string& weapon() const;
  inline void set_weapon(const ::std::string& value);
  inline void set_weapon(const char* value);
  inline void set_weapon(const char* value, size_t size);
  inline ::std::string* mutable_weapon();
  inline ::std::string* release_weapon();
  inline void set_allocated_weapon(::std::string* weapon);

  // optional string skill = 5;
  inline bool has_skill() const;
  inline void clear_skill();
  static const int kSkillFieldNumber = 5;
  inline const ::std::string& skill() const;
  inline void set_skill(const ::std::string& value);
  inline void set_skill(const char* value);
  inline void set_skill(const char* value, size_t size);
  inline ::std::string* mutable_skill();
  inline ::std::string* release_skill();
  inline void set_allocated_skill(::std::string* skill);

  // optional uint32 accountid = 6;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 6;
  inline ::google::protobuf::uint32 accountid() const;
  inline void set_accountid(::google::protobuf::uint32 value);

  // optional float style = 7;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 7;
  inline float style() const;
  inline void set_style(float value);

  // optional float total_style = 8;
  inline bool has_total_style() const;
  inline void clear_total_style();
  static const int kTotalStyleFieldNumber = 8;
  inline float total_style() const;
  inline void set_total_style(float value);

  // optional uint32 kills = 9;
  inline bool has_kills() const;
  inline void clear_kills();
  static const int kKillsFieldNumber = 9;
  inline ::google::protobuf::uint32 kills() const;
  inline void set_kills(::google::protobuf::uint32 value);

  // optional uint32 deaths = 10;
  inline bool has_deaths() const;
  inline void clear_deaths();
  static const int kDeathsFieldNumber = 10;
  inline ::google::protobuf::uint32 deaths() const;
  inline void set_deaths(::google::protobuf::uint32 value);

  // optional uint32 waypoint = 11;
  inline bool has_waypoint() const;
  inline void clear_waypoint();
  static const int kWaypointFieldNumber = 11;
  inline ::google::protobuf::uint32 waypoint() const;
  inline void set_waypoint(::google::protobuf::uint32 value);

  // optional .da.protobuf.Vector objective_position = 12;
  inline bool has_objective_position() const;
  inline void clear_objective_position();
  static const int kObjectivePositionFieldNumber = 12;
  inline const ::da::protobuf::Vector& objective_position() const;
  inline ::da::protobuf::Vector* mutable_objective_position();
  inline ::da::protobuf::Vector* release_objective_position();
  inline void set_allocated_objective_position(::da::protobuf::Vector* objective_position);

  // optional string slowmo_type = 13;
  inline bool has_slowmo_type() const;
  inline void clear_slowmo_type();
  static const int kSlowmoTypeFieldNumber = 13;
  inline const ::std::string& slowmo_type() const;
  inline void set_slowmo_type(const ::std::string& value);
  inline void set_slowmo_type(const char* value);
  inline void set_slowmo_type(const char* value, size_t size);
  inline ::std::string* mutable_slowmo_type();
  inline ::std::string* release_slowmo_type();
  inline void set_allocated_slowmo_type(::std::string* slowmo_type);

  // optional float slowmo_seconds = 14;
  inline bool has_slowmo_seconds() const;
  inline void clear_slowmo_seconds();
  static const int kSlowmoSecondsFieldNumber = 14;
  inline float slowmo_seconds() const;
  inline void set_slowmo_seconds(float value);

  // @@protoc_insertion_point(class_scope:da.protobuf.PlayerInfo)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_health();
  inline void clear_has_health();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_weapon();
  inline void clear_has_weapon();
  inline void set_has_skill();
  inline void clear_has_skill();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_total_style();
  inline void clear_has_total_style();
  inline void set_has_kills();
  inline void clear_has_kills();
  inline void set_has_deaths();
  inline void clear_has_deaths();
  inline void set_has_waypoint();
  inline void clear_has_waypoint();
  inline void set_has_objective_position();
  inline void clear_has_objective_position();
  inline void set_has_slowmo_type();
  inline void clear_has_slowmo_type();
  inline void set_has_slowmo_seconds();
  inline void clear_has_slowmo_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::da::protobuf::Vector* position_;
  ::google::protobuf::uint64 flags_;
  ::std::string* weapon_;
  ::google::protobuf::int32 health_;
  ::google::protobuf::uint32 accountid_;
  ::std::string* skill_;
  float style_;
  float total_style_;
  ::google::protobuf::uint32 kills_;
  ::google::protobuf::uint32 deaths_;
  ::da::protobuf::Vector* objective_position_;
  ::google::protobuf::uint32 waypoint_;
  float slowmo_seconds_;
  ::std::string* slowmo_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();

  void InitAsDefaultInstance();
  static PlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class KillInfo : public ::google::protobuf::Message {
 public:
  KillInfo();
  virtual ~KillInfo();

  KillInfo(const KillInfo& from);

  inline KillInfo& operator=(const KillInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KillInfo& default_instance();

  void Swap(KillInfo* other);

  // implements Message ----------------------------------------------

  KillInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KillInfo& from);
  void MergeFrom(const KillInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .da.protobuf.PlayerInfo victim = 1;
  inline bool has_victim() const;
  inline void clear_victim();
  static const int kVictimFieldNumber = 1;
  inline const ::da::protobuf::PlayerInfo& victim() const;
  inline ::da::protobuf::PlayerInfo* mutable_victim();
  inline ::da::protobuf::PlayerInfo* release_victim();
  inline void set_allocated_victim(::da::protobuf::PlayerInfo* victim);

  // optional .da.protobuf.PlayerInfo killer = 2;
  inline bool has_killer() const;
  inline void clear_killer();
  static const int kKillerFieldNumber = 2;
  inline const ::da::protobuf::PlayerInfo& killer() const;
  inline ::da::protobuf::PlayerInfo* mutable_killer();
  inline ::da::protobuf::PlayerInfo* release_killer();
  inline void set_allocated_killer(::da::protobuf::PlayerInfo* killer);

  // optional .da.protobuf.Vector grenade_position = 3;
  inline bool has_grenade_position() const;
  inline void clear_grenade_position();
  static const int kGrenadePositionFieldNumber = 3;
  inline const ::da::protobuf::Vector& grenade_position() const;
  inline ::da::protobuf::Vector* mutable_grenade_position();
  inline ::da::protobuf::Vector* release_grenade_position();
  inline void set_allocated_grenade_position(::da::protobuf::Vector* grenade_position);

  // @@protoc_insertion_point(class_scope:da.protobuf.KillInfo)
 private:
  inline void set_has_victim();
  inline void clear_has_victim();
  inline void set_has_killer();
  inline void clear_has_killer();
  inline void set_has_grenade_position();
  inline void clear_has_grenade_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::da::protobuf::PlayerInfo* victim_;
  ::da::protobuf::PlayerInfo* killer_;
  ::da::protobuf::Vector* grenade_position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();

  void InitAsDefaultInstance();
  static KillInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayerList : public ::google::protobuf::Message {
 public:
  PlayerList();
  virtual ~PlayerList();

  PlayerList(const PlayerList& from);

  inline PlayerList& operator=(const PlayerList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerList& default_instance();

  void Swap(PlayerList* other);

  // implements Message ----------------------------------------------

  PlayerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerList& from);
  void MergeFrom(const PlayerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 accountid = 1;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 1;
  inline ::google::protobuf::int32 accountid() const;
  inline void set_accountid(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional float style = 3;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 3;
  inline float style() const;
  inline void set_style(float value);

  // @@protoc_insertion_point(class_scope:da.protobuf.PlayerList)
 private:
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_style();
  inline void clear_has_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 accountid_;
  float style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();

  void InitAsDefaultInstance();
  static PlayerList* default_instance_;
};
// -------------------------------------------------------------------

class ServerReply : public ::google::protobuf::Message {
 public:
  ServerReply();
  virtual ~ServerReply();

  ServerReply(const ServerReply& from);

  inline ServerReply& operator=(const ServerReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerReply& default_instance();

  void Swap(ServerReply* other);

  // implements Message ----------------------------------------------

  ServerReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerReply& from);
  void MergeFrom(const ServerReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string daily_leader = 1;
  inline bool has_daily_leader() const;
  inline void clear_daily_leader();
  static const int kDailyLeaderFieldNumber = 1;
  inline const ::std::string& daily_leader() const;
  inline void set_daily_leader(const ::std::string& value);
  inline void set_daily_leader(const char* value);
  inline void set_daily_leader(const char* value, size_t size);
  inline ::std::string* mutable_daily_leader();
  inline ::std::string* release_daily_leader();
  inline void set_allocated_daily_leader(::std::string* daily_leader);

  // optional float daily_leader_style = 2;
  inline bool has_daily_leader_style() const;
  inline void clear_daily_leader_style();
  static const int kDailyLeaderStyleFieldNumber = 2;
  inline float daily_leader_style() const;
  inline void set_daily_leader_style(float value);

  // optional string weekly_leader = 3;
  inline bool has_weekly_leader() const;
  inline void clear_weekly_leader();
  static const int kWeeklyLeaderFieldNumber = 3;
  inline const ::std::string& weekly_leader() const;
  inline void set_weekly_leader(const ::std::string& value);
  inline void set_weekly_leader(const char* value);
  inline void set_weekly_leader(const char* value, size_t size);
  inline ::std::string* mutable_weekly_leader();
  inline ::std::string* release_weekly_leader();
  inline void set_allocated_weekly_leader(::std::string* weekly_leader);

  // optional float weekly_leader_style = 4;
  inline bool has_weekly_leader_style() const;
  inline void clear_weekly_leader_style();
  static const int kWeeklyLeaderStyleFieldNumber = 4;
  inline float weekly_leader_style() const;
  inline void set_weekly_leader_style(float value);

  // optional string monthly_leader = 5;
  inline bool has_monthly_leader() const;
  inline void clear_monthly_leader();
  static const int kMonthlyLeaderFieldNumber = 5;
  inline const ::std::string& monthly_leader() const;
  inline void set_monthly_leader(const ::std::string& value);
  inline void set_monthly_leader(const char* value);
  inline void set_monthly_leader(const char* value, size_t size);
  inline ::std::string* mutable_monthly_leader();
  inline ::std::string* release_monthly_leader();
  inline void set_allocated_monthly_leader(::std::string* monthly_leader);

  // optional float monthly_leader_style = 6;
  inline bool has_monthly_leader_style() const;
  inline void clear_monthly_leader_style();
  static const int kMonthlyLeaderStyleFieldNumber = 6;
  inline float monthly_leader_style() const;
  inline void set_monthly_leader_style(float value);

  // @@protoc_insertion_point(class_scope:da.protobuf.ServerReply)
 private:
  inline void set_has_daily_leader();
  inline void clear_has_daily_leader();
  inline void set_has_daily_leader_style();
  inline void clear_has_daily_leader_style();
  inline void set_has_weekly_leader();
  inline void clear_has_weekly_leader();
  inline void set_has_weekly_leader_style();
  inline void clear_has_weekly_leader_style();
  inline void set_has_monthly_leader();
  inline void clear_has_monthly_leader();
  inline void set_has_monthly_leader_style();
  inline void clear_has_monthly_leader_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* daily_leader_;
  ::std::string* weekly_leader_;
  float daily_leader_style_;
  float weekly_leader_style_;
  ::std::string* monthly_leader_;
  float monthly_leader_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_data_2eproto();
  friend void protobuf_AssignDesc_data_2eproto();
  friend void protobuf_ShutdownFile_data_2eproto();

  void InitAsDefaultInstance();
  static ServerReply* default_instance_;
};
// ===================================================================


// ===================================================================

// GameData

// optional bool debug = 1;
inline bool GameData::has_debug() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameData::set_has_debug() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameData::clear_has_debug() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameData::clear_debug() {
  debug_ = false;
  clear_has_debug();
}
inline bool GameData::debug() const {
  return debug_;
}
inline void GameData::set_debug(bool value) {
  set_has_debug();
  debug_ = value;
}

// optional string map_name = 2;
inline bool GameData::has_map_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameData::set_has_map_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameData::clear_has_map_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameData::clear_map_name() {
  if (map_name_ != &::google::protobuf::internal::kEmptyString) {
    map_name_->clear();
  }
  clear_has_map_name();
}
inline const ::std::string& GameData::map_name() const {
  return *map_name_;
}
inline void GameData::set_map_name(const ::std::string& value) {
  set_has_map_name();
  if (map_name_ == &::google::protobuf::internal::kEmptyString) {
    map_name_ = new ::std::string;
  }
  map_name_->assign(value);
}
inline void GameData::set_map_name(const char* value) {
  set_has_map_name();
  if (map_name_ == &::google::protobuf::internal::kEmptyString) {
    map_name_ = new ::std::string;
  }
  map_name_->assign(value);
}
inline void GameData::set_map_name(const char* value, size_t size) {
  set_has_map_name();
  if (map_name_ == &::google::protobuf::internal::kEmptyString) {
    map_name_ = new ::std::string;
  }
  map_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameData::mutable_map_name() {
  set_has_map_name();
  if (map_name_ == &::google::protobuf::internal::kEmptyString) {
    map_name_ = new ::std::string;
  }
  return map_name_;
}
inline ::std::string* GameData::release_map_name() {
  clear_has_map_name();
  if (map_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_name_;
    map_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameData::set_allocated_map_name(::std::string* map_name) {
  if (map_name_ != &::google::protobuf::internal::kEmptyString) {
    delete map_name_;
  }
  if (map_name) {
    set_has_map_name();
    map_name_ = map_name;
  } else {
    clear_has_map_name();
    map_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string server_name = 3;
inline bool GameData::has_server_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameData::set_has_server_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameData::clear_has_server_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameData::clear_server_name() {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    server_name_->clear();
  }
  clear_has_server_name();
}
inline const ::std::string& GameData::server_name() const {
  return *server_name_;
}
inline void GameData::set_server_name(const ::std::string& value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void GameData::set_server_name(const char* value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void GameData::set_server_name(const char* value, size_t size) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameData::mutable_server_name() {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  return server_name_;
}
inline ::std::string* GameData::release_server_name() {
  clear_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_name_;
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameData::set_allocated_server_name(::std::string* server_name) {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    delete server_name_;
  }
  if (server_name) {
    set_has_server_name();
    server_name_ = server_name;
  } else {
    clear_has_server_name();
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 timestamp = 4;
inline bool GameData::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameData::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameData::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameData::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 GameData::timestamp() const {
  return timestamp_;
}
inline void GameData::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .da.protobuf.PlayerPositions positions = 5;
inline bool GameData::has_positions() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameData::set_has_positions() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameData::clear_has_positions() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameData::clear_positions() {
  if (positions_ != NULL) positions_->::da::protobuf::PlayerPositions::Clear();
  clear_has_positions();
}
inline const ::da::protobuf::PlayerPositions& GameData::positions() const {
  return positions_ != NULL ? *positions_ : *default_instance_->positions_;
}
inline ::da::protobuf::PlayerPositions* GameData::mutable_positions() {
  set_has_positions();
  if (positions_ == NULL) positions_ = new ::da::protobuf::PlayerPositions;
  return positions_;
}
inline ::da::protobuf::PlayerPositions* GameData::release_positions() {
  clear_has_positions();
  ::da::protobuf::PlayerPositions* temp = positions_;
  positions_ = NULL;
  return temp;
}
inline void GameData::set_allocated_positions(::da::protobuf::PlayerPositions* positions) {
  delete positions_;
  positions_ = positions;
  if (positions) {
    set_has_positions();
  } else {
    clear_has_positions();
  }
}

// optional bool cheats = 6;
inline bool GameData::has_cheats() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameData::set_has_cheats() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameData::clear_has_cheats() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameData::clear_cheats() {
  cheats_ = false;
  clear_has_cheats();
}
inline bool GameData::cheats() const {
  return cheats_;
}
inline void GameData::set_cheats(bool value) {
  set_has_cheats();
  cheats_ = value;
}

// optional .da.protobuf.PlayerPositions kills = 7;
inline bool GameData::has_kills() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameData::set_has_kills() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameData::clear_has_kills() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameData::clear_kills() {
  if (kills_ != NULL) kills_->::da::protobuf::PlayerPositions::Clear();
  clear_has_kills();
}
inline const ::da::protobuf::PlayerPositions& GameData::kills() const {
  return kills_ != NULL ? *kills_ : *default_instance_->kills_;
}
inline ::da::protobuf::PlayerPositions* GameData::mutable_kills() {
  set_has_kills();
  if (kills_ == NULL) kills_ = new ::da::protobuf::PlayerPositions;
  return kills_;
}
inline ::da::protobuf::PlayerPositions* GameData::release_kills() {
  clear_has_kills();
  ::da::protobuf::PlayerPositions* temp = kills_;
  kills_ = NULL;
  return temp;
}
inline void GameData::set_allocated_kills(::da::protobuf::PlayerPositions* kills) {
  delete kills_;
  kills_ = kills;
  if (kills) {
    set_has_kills();
  } else {
    clear_has_kills();
  }
}

// optional .da.protobuf.PlayerPositions deaths = 8;
inline bool GameData::has_deaths() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameData::set_has_deaths() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameData::clear_has_deaths() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameData::clear_deaths() {
  if (deaths_ != NULL) deaths_->::da::protobuf::PlayerPositions::Clear();
  clear_has_deaths();
}
inline const ::da::protobuf::PlayerPositions& GameData::deaths() const {
  return deaths_ != NULL ? *deaths_ : *default_instance_->deaths_;
}
inline ::da::protobuf::PlayerPositions* GameData::mutable_deaths() {
  set_has_deaths();
  if (deaths_ == NULL) deaths_ = new ::da::protobuf::PlayerPositions;
  return deaths_;
}
inline ::da::protobuf::PlayerPositions* GameData::release_deaths() {
  clear_has_deaths();
  ::da::protobuf::PlayerPositions* temp = deaths_;
  deaths_ = NULL;
  return temp;
}
inline void GameData::set_allocated_deaths(::da::protobuf::PlayerPositions* deaths) {
  delete deaths_;
  deaths_ = deaths;
  if (deaths) {
    set_has_deaths();
  } else {
    clear_has_deaths();
  }
}

// optional int32 connections = 9;
inline bool GameData::has_connections() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameData::set_has_connections() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameData::clear_has_connections() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameData::clear_connections() {
  connections_ = 0;
  clear_has_connections();
}
inline ::google::protobuf::int32 GameData::connections() const {
  return connections_;
}
inline void GameData::set_connections(::google::protobuf::int32 value) {
  set_has_connections();
  connections_ = value;
}

// optional bool teamplay = 10;
inline bool GameData::has_teamplay() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GameData::set_has_teamplay() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GameData::clear_has_teamplay() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GameData::clear_teamplay() {
  teamplay_ = false;
  clear_has_teamplay();
}
inline bool GameData::teamplay() const {
  return teamplay_;
}
inline void GameData::set_teamplay(bool value) {
  set_has_teamplay();
  teamplay_ = value;
}

// optional int32 thirdperson_active = 11;
inline bool GameData::has_thirdperson_active() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GameData::set_has_thirdperson_active() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GameData::clear_has_thirdperson_active() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GameData::clear_thirdperson_active() {
  thirdperson_active_ = 0;
  clear_has_thirdperson_active();
}
inline ::google::protobuf::int32 GameData::thirdperson_active() const {
  return thirdperson_active_;
}
inline void GameData::set_thirdperson_active(::google::protobuf::int32 value) {
  set_has_thirdperson_active();
  thirdperson_active_ = value;
}

// optional int32 thirdperson_inactive = 12;
inline bool GameData::has_thirdperson_inactive() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GameData::set_has_thirdperson_inactive() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GameData::clear_has_thirdperson_inactive() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GameData::clear_thirdperson_inactive() {
  thirdperson_inactive_ = 0;
  clear_has_thirdperson_inactive();
}
inline ::google::protobuf::int32 GameData::thirdperson_inactive() const {
  return thirdperson_inactive_;
}
inline void GameData::set_thirdperson_inactive(::google::protobuf::int32 value) {
  set_has_thirdperson_inactive();
  thirdperson_inactive_ = value;
}

// optional int32 disconnections = 13;
inline bool GameData::has_disconnections() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GameData::set_has_disconnections() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GameData::clear_has_disconnections() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GameData::clear_disconnections() {
  disconnections_ = 0;
  clear_has_disconnections();
}
inline ::google::protobuf::int32 GameData::disconnections() const {
  return disconnections_;
}
inline void GameData::set_disconnections(::google::protobuf::int32 value) {
  set_has_disconnections();
  disconnections_ = value;
}

// optional int32 unique_players_this_map = 14;
inline bool GameData::has_unique_players_this_map() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GameData::set_has_unique_players_this_map() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GameData::clear_has_unique_players_this_map() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GameData::clear_unique_players_this_map() {
  unique_players_this_map_ = 0;
  clear_has_unique_players_this_map();
}
inline ::google::protobuf::int32 GameData::unique_players_this_map() const {
  return unique_players_this_map_;
}
inline void GameData::set_unique_players_this_map(::google::protobuf::int32 value) {
  set_has_unique_players_this_map();
  unique_players_this_map_ = value;
}

// optional int32 da_version = 15;
inline bool GameData::has_da_version() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GameData::set_has_da_version() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GameData::clear_has_da_version() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GameData::clear_da_version() {
  da_version_ = 0;
  clear_has_da_version();
}
inline ::google::protobuf::int32 GameData::da_version() const {
  return da_version_;
}
inline void GameData::set_da_version(::google::protobuf::int32 value) {
  set_has_da_version();
  da_version_ = value;
}

// repeated string characters_chosen = 16;
inline int GameData::characters_chosen_size() const {
  return characters_chosen_.size();
}
inline void GameData::clear_characters_chosen() {
  characters_chosen_.Clear();
}
inline const ::std::string& GameData::characters_chosen(int index) const {
  return characters_chosen_.Get(index);
}
inline ::std::string* GameData::mutable_characters_chosen(int index) {
  return characters_chosen_.Mutable(index);
}
inline void GameData::set_characters_chosen(int index, const ::std::string& value) {
  characters_chosen_.Mutable(index)->assign(value);
}
inline void GameData::set_characters_chosen(int index, const char* value) {
  characters_chosen_.Mutable(index)->assign(value);
}
inline void GameData::set_characters_chosen(int index, const char* value, size_t size) {
  characters_chosen_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameData::add_characters_chosen() {
  return characters_chosen_.Add();
}
inline void GameData::add_characters_chosen(const ::std::string& value) {
  characters_chosen_.Add()->assign(value);
}
inline void GameData::add_characters_chosen(const char* value) {
  characters_chosen_.Add()->assign(value);
}
inline void GameData::add_characters_chosen(const char* value, size_t size) {
  characters_chosen_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GameData::characters_chosen() const {
  return characters_chosen_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GameData::mutable_characters_chosen() {
  return &characters_chosen_;
}

// repeated int32 weapons_chosen = 17;
inline int GameData::weapons_chosen_size() const {
  return weapons_chosen_.size();
}
inline void GameData::clear_weapons_chosen() {
  weapons_chosen_.Clear();
}
inline ::google::protobuf::int32 GameData::weapons_chosen(int index) const {
  return weapons_chosen_.Get(index);
}
inline void GameData::set_weapons_chosen(int index, ::google::protobuf::int32 value) {
  weapons_chosen_.Set(index, value);
}
inline void GameData::add_weapons_chosen(::google::protobuf::int32 value) {
  weapons_chosen_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GameData::weapons_chosen() const {
  return weapons_chosen_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GameData::mutable_weapons_chosen() {
  return &weapons_chosen_;
}

// repeated int32 skills_chosen = 18;
inline int GameData::skills_chosen_size() const {
  return skills_chosen_.size();
}
inline void GameData::clear_skills_chosen() {
  skills_chosen_.Clear();
}
inline ::google::protobuf::int32 GameData::skills_chosen(int index) const {
  return skills_chosen_.Get(index);
}
inline void GameData::set_skills_chosen(int index, ::google::protobuf::int32 value) {
  skills_chosen_.Set(index, value);
}
inline void GameData::add_skills_chosen(::google::protobuf::int32 value) {
  skills_chosen_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GameData::skills_chosen() const {
  return skills_chosen_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GameData::mutable_skills_chosen() {
  return &skills_chosen_;
}

// repeated .da.protobuf.VoteResult votes = 19;
inline int GameData::votes_size() const {
  return votes_.size();
}
inline void GameData::clear_votes() {
  votes_.Clear();
}
inline const ::da::protobuf::VoteResult& GameData::votes(int index) const {
  return votes_.Get(index);
}
inline ::da::protobuf::VoteResult* GameData::mutable_votes(int index) {
  return votes_.Mutable(index);
}
inline ::da::protobuf::VoteResult* GameData::add_votes() {
  return votes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::da::protobuf::VoteResult >&
GameData::votes() const {
  return votes_;
}
inline ::google::protobuf::RepeatedPtrField< ::da::protobuf::VoteResult >*
GameData::mutable_votes() {
  return &votes_;
}

// repeated string weapons_chosen_s = 20;
inline int GameData::weapons_chosen_s_size() const {
  return weapons_chosen_s_.size();
}
inline void GameData::clear_weapons_chosen_s() {
  weapons_chosen_s_.Clear();
}
inline const ::std::string& GameData::weapons_chosen_s(int index) const {
  return weapons_chosen_s_.Get(index);
}
inline ::std::string* GameData::mutable_weapons_chosen_s(int index) {
  return weapons_chosen_s_.Mutable(index);
}
inline void GameData::set_weapons_chosen_s(int index, const ::std::string& value) {
  weapons_chosen_s_.Mutable(index)->assign(value);
}
inline void GameData::set_weapons_chosen_s(int index, const char* value) {
  weapons_chosen_s_.Mutable(index)->assign(value);
}
inline void GameData::set_weapons_chosen_s(int index, const char* value, size_t size) {
  weapons_chosen_s_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameData::add_weapons_chosen_s() {
  return weapons_chosen_s_.Add();
}
inline void GameData::add_weapons_chosen_s(const ::std::string& value) {
  weapons_chosen_s_.Add()->assign(value);
}
inline void GameData::add_weapons_chosen_s(const char* value) {
  weapons_chosen_s_.Add()->assign(value);
}
inline void GameData::add_weapons_chosen_s(const char* value, size_t size) {
  weapons_chosen_s_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GameData::weapons_chosen_s() const {
  return weapons_chosen_s_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GameData::mutable_weapons_chosen_s() {
  return &weapons_chosen_s_;
}

// repeated string skills_chosen_s = 21;
inline int GameData::skills_chosen_s_size() const {
  return skills_chosen_s_.size();
}
inline void GameData::clear_skills_chosen_s() {
  skills_chosen_s_.Clear();
}
inline const ::std::string& GameData::skills_chosen_s(int index) const {
  return skills_chosen_s_.Get(index);
}
inline ::std::string* GameData::mutable_skills_chosen_s(int index) {
  return skills_chosen_s_.Mutable(index);
}
inline void GameData::set_skills_chosen_s(int index, const ::std::string& value) {
  skills_chosen_s_.Mutable(index)->assign(value);
}
inline void GameData::set_skills_chosen_s(int index, const char* value) {
  skills_chosen_s_.Mutable(index)->assign(value);
}
inline void GameData::set_skills_chosen_s(int index, const char* value, size_t size) {
  skills_chosen_s_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameData::add_skills_chosen_s() {
  return skills_chosen_s_.Add();
}
inline void GameData::add_skills_chosen_s(const ::std::string& value) {
  skills_chosen_s_.Add()->assign(value);
}
inline void GameData::add_skills_chosen_s(const char* value) {
  skills_chosen_s_.Add()->assign(value);
}
inline void GameData::add_skills_chosen_s(const char* value, size_t size) {
  skills_chosen_s_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GameData::skills_chosen_s() const {
  return skills_chosen_s_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GameData::mutable_skills_chosen_s() {
  return &skills_chosen_s_;
}

// optional float map_time = 22;
inline bool GameData::has_map_time() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GameData::set_has_map_time() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GameData::clear_has_map_time() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GameData::clear_map_time() {
  map_time_ = 0;
  clear_has_map_time();
}
inline float GameData::map_time() const {
  return map_time_;
}
inline void GameData::set_map_time(float value) {
  set_has_map_time();
  map_time_ = value;
}

// optional int32 vr_active = 23;
inline bool GameData::has_vr_active() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GameData::set_has_vr_active() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GameData::clear_has_vr_active() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GameData::clear_vr_active() {
  vr_active_ = 0;
  clear_has_vr_active();
}
inline ::google::protobuf::int32 GameData::vr_active() const {
  return vr_active_;
}
inline void GameData::set_vr_active(::google::protobuf::int32 value) {
  set_has_vr_active();
  vr_active_ = value;
}

// optional int32 vr_inactive = 24;
inline bool GameData::has_vr_inactive() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void GameData::set_has_vr_inactive() {
  _has_bits_[0] |= 0x00800000u;
}
inline void GameData::clear_has_vr_inactive() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void GameData::clear_vr_inactive() {
  vr_inactive_ = 0;
  clear_has_vr_inactive();
}
inline ::google::protobuf::int32 GameData::vr_inactive() const {
  return vr_inactive_;
}
inline void GameData::set_vr_inactive(::google::protobuf::int32 value) {
  set_has_vr_inactive();
  vr_inactive_ = value;
}

// optional int32 platform_windows = 25;
inline bool GameData::has_platform_windows() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void GameData::set_has_platform_windows() {
  _has_bits_[0] |= 0x01000000u;
}
inline void GameData::clear_has_platform_windows() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void GameData::clear_platform_windows() {
  platform_windows_ = 0;
  clear_has_platform_windows();
}
inline ::google::protobuf::int32 GameData::platform_windows() const {
  return platform_windows_;
}
inline void GameData::set_platform_windows(::google::protobuf::int32 value) {
  set_has_platform_windows();
  platform_windows_ = value;
}

// optional int32 platform_linux = 26;
inline bool GameData::has_platform_linux() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void GameData::set_has_platform_linux() {
  _has_bits_[0] |= 0x02000000u;
}
inline void GameData::clear_has_platform_linux() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void GameData::clear_platform_linux() {
  platform_linux_ = 0;
  clear_has_platform_linux();
}
inline ::google::protobuf::int32 GameData::platform_linux() const {
  return platform_linux_;
}
inline void GameData::set_platform_linux(::google::protobuf::int32 value) {
  set_has_platform_linux();
  platform_linux_ = value;
}

// optional int32 platform_osx = 27;
inline bool GameData::has_platform_osx() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void GameData::set_has_platform_osx() {
  _has_bits_[0] |= 0x04000000u;
}
inline void GameData::clear_has_platform_osx() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void GameData::clear_platform_osx() {
  platform_osx_ = 0;
  clear_has_platform_osx();
}
inline ::google::protobuf::int32 GameData::platform_osx() const {
  return platform_osx_;
}
inline void GameData::set_platform_osx(::google::protobuf::int32 value) {
  set_has_platform_osx();
  platform_osx_ = value;
}

// repeated .da.protobuf.KillInfo kill_details = 28;
inline int GameData::kill_details_size() const {
  return kill_details_.size();
}
inline void GameData::clear_kill_details() {
  kill_details_.Clear();
}
inline const ::da::protobuf::KillInfo& GameData::kill_details(int index) const {
  return kill_details_.Get(index);
}
inline ::da::protobuf::KillInfo* GameData::mutable_kill_details(int index) {
  return kill_details_.Mutable(index);
}
inline ::da::protobuf::KillInfo* GameData::add_kill_details() {
  return kill_details_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::da::protobuf::KillInfo >&
GameData::kill_details() const {
  return kill_details_;
}
inline ::google::protobuf::RepeatedPtrField< ::da::protobuf::KillInfo >*
GameData::mutable_kill_details() {
  return &kill_details_;
}

// repeated .da.protobuf.PlayerList player_list = 29;
inline int GameData::player_list_size() const {
  return player_list_.size();
}
inline void GameData::clear_player_list() {
  player_list_.Clear();
}
inline const ::da::protobuf::PlayerList& GameData::player_list(int index) const {
  return player_list_.Get(index);
}
inline ::da::protobuf::PlayerList* GameData::mutable_player_list(int index) {
  return player_list_.Mutable(index);
}
inline ::da::protobuf::PlayerList* GameData::add_player_list() {
  return player_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::da::protobuf::PlayerList >&
GameData::player_list() const {
  return player_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::da::protobuf::PlayerList >*
GameData::mutable_player_list() {
  return &player_list_;
}

// -------------------------------------------------------------------

// PlayerPositions

// repeated .da.protobuf.Vector position = 1;
inline int PlayerPositions::position_size() const {
  return position_.size();
}
inline void PlayerPositions::clear_position() {
  position_.Clear();
}
inline const ::da::protobuf::Vector& PlayerPositions::position(int index) const {
  return position_.Get(index);
}
inline ::da::protobuf::Vector* PlayerPositions::mutable_position(int index) {
  return position_.Mutable(index);
}
inline ::da::protobuf::Vector* PlayerPositions::add_position() {
  return position_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::da::protobuf::Vector >&
PlayerPositions::position() const {
  return position_;
}
inline ::google::protobuf::RepeatedPtrField< ::da::protobuf::Vector >*
PlayerPositions::mutable_position() {
  return &position_;
}

// -------------------------------------------------------------------

// VoteResult

// optional string issue = 1;
inline bool VoteResult::has_issue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VoteResult::set_has_issue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VoteResult::clear_has_issue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VoteResult::clear_issue() {
  if (issue_ != &::google::protobuf::internal::kEmptyString) {
    issue_->clear();
  }
  clear_has_issue();
}
inline const ::std::string& VoteResult::issue() const {
  return *issue_;
}
inline void VoteResult::set_issue(const ::std::string& value) {
  set_has_issue();
  if (issue_ == &::google::protobuf::internal::kEmptyString) {
    issue_ = new ::std::string;
  }
  issue_->assign(value);
}
inline void VoteResult::set_issue(const char* value) {
  set_has_issue();
  if (issue_ == &::google::protobuf::internal::kEmptyString) {
    issue_ = new ::std::string;
  }
  issue_->assign(value);
}
inline void VoteResult::set_issue(const char* value, size_t size) {
  set_has_issue();
  if (issue_ == &::google::protobuf::internal::kEmptyString) {
    issue_ = new ::std::string;
  }
  issue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VoteResult::mutable_issue() {
  set_has_issue();
  if (issue_ == &::google::protobuf::internal::kEmptyString) {
    issue_ = new ::std::string;
  }
  return issue_;
}
inline ::std::string* VoteResult::release_issue() {
  clear_has_issue();
  if (issue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = issue_;
    issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VoteResult::set_allocated_issue(::std::string* issue) {
  if (issue_ != &::google::protobuf::internal::kEmptyString) {
    delete issue_;
  }
  if (issue) {
    set_has_issue();
    issue_ = issue;
  } else {
    clear_has_issue();
    issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string details = 2;
inline bool VoteResult::has_details() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VoteResult::set_has_details() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VoteResult::clear_has_details() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VoteResult::clear_details() {
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    details_->clear();
  }
  clear_has_details();
}
inline const ::std::string& VoteResult::details() const {
  return *details_;
}
inline void VoteResult::set_details(const ::std::string& value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void VoteResult::set_details(const char* value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void VoteResult::set_details(const char* value, size_t size) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VoteResult::mutable_details() {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  return details_;
}
inline ::std::string* VoteResult::release_details() {
  clear_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = details_;
    details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VoteResult::set_allocated_details(::std::string* details) {
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    delete details_;
  }
  if (details) {
    set_has_details();
    details_ = details;
  } else {
    clear_has_details();
    details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool result = 3;
inline bool VoteResult::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VoteResult::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VoteResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VoteResult::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool VoteResult::result() const {
  return result_;
}
inline void VoteResult::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// PlayerInfo

// optional .da.protobuf.Vector position = 1;
inline bool PlayerInfo::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfo::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfo::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfo::clear_position() {
  if (position_ != NULL) position_->::da::protobuf::Vector::Clear();
  clear_has_position();
}
inline const ::da::protobuf::Vector& PlayerInfo::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::da::protobuf::Vector* PlayerInfo::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::da::protobuf::Vector;
  return position_;
}
inline ::da::protobuf::Vector* PlayerInfo::release_position() {
  clear_has_position();
  ::da::protobuf::Vector* temp = position_;
  position_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_position(::da::protobuf::Vector* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// optional int32 health = 2;
inline bool PlayerInfo::has_health() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfo::set_has_health() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfo::clear_has_health() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfo::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline ::google::protobuf::int32 PlayerInfo::health() const {
  return health_;
}
inline void PlayerInfo::set_health(::google::protobuf::int32 value) {
  set_has_health();
  health_ = value;
}

// optional uint64 flags = 3;
inline bool PlayerInfo::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerInfo::set_has_flags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerInfo::clear_has_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerInfo::clear_flags() {
  flags_ = GOOGLE_ULONGLONG(0);
  clear_has_flags();
}
inline ::google::protobuf::uint64 PlayerInfo::flags() const {
  return flags_;
}
inline void PlayerInfo::set_flags(::google::protobuf::uint64 value) {
  set_has_flags();
  flags_ = value;
}

// optional string weapon = 4;
inline bool PlayerInfo::has_weapon() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerInfo::set_has_weapon() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerInfo::clear_has_weapon() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerInfo::clear_weapon() {
  if (weapon_ != &::google::protobuf::internal::kEmptyString) {
    weapon_->clear();
  }
  clear_has_weapon();
}
inline const ::std::string& PlayerInfo::weapon() const {
  return *weapon_;
}
inline void PlayerInfo::set_weapon(const ::std::string& value) {
  set_has_weapon();
  if (weapon_ == &::google::protobuf::internal::kEmptyString) {
    weapon_ = new ::std::string;
  }
  weapon_->assign(value);
}
inline void PlayerInfo::set_weapon(const char* value) {
  set_has_weapon();
  if (weapon_ == &::google::protobuf::internal::kEmptyString) {
    weapon_ = new ::std::string;
  }
  weapon_->assign(value);
}
inline void PlayerInfo::set_weapon(const char* value, size_t size) {
  set_has_weapon();
  if (weapon_ == &::google::protobuf::internal::kEmptyString) {
    weapon_ = new ::std::string;
  }
  weapon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerInfo::mutable_weapon() {
  set_has_weapon();
  if (weapon_ == &::google::protobuf::internal::kEmptyString) {
    weapon_ = new ::std::string;
  }
  return weapon_;
}
inline ::std::string* PlayerInfo::release_weapon() {
  clear_has_weapon();
  if (weapon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weapon_;
    weapon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerInfo::set_allocated_weapon(::std::string* weapon) {
  if (weapon_ != &::google::protobuf::internal::kEmptyString) {
    delete weapon_;
  }
  if (weapon) {
    set_has_weapon();
    weapon_ = weapon;
  } else {
    clear_has_weapon();
    weapon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string skill = 5;
inline bool PlayerInfo::has_skill() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerInfo::set_has_skill() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerInfo::clear_has_skill() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerInfo::clear_skill() {
  if (skill_ != &::google::protobuf::internal::kEmptyString) {
    skill_->clear();
  }
  clear_has_skill();
}
inline const ::std::string& PlayerInfo::skill() const {
  return *skill_;
}
inline void PlayerInfo::set_skill(const ::std::string& value) {
  set_has_skill();
  if (skill_ == &::google::protobuf::internal::kEmptyString) {
    skill_ = new ::std::string;
  }
  skill_->assign(value);
}
inline void PlayerInfo::set_skill(const char* value) {
  set_has_skill();
  if (skill_ == &::google::protobuf::internal::kEmptyString) {
    skill_ = new ::std::string;
  }
  skill_->assign(value);
}
inline void PlayerInfo::set_skill(const char* value, size_t size) {
  set_has_skill();
  if (skill_ == &::google::protobuf::internal::kEmptyString) {
    skill_ = new ::std::string;
  }
  skill_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerInfo::mutable_skill() {
  set_has_skill();
  if (skill_ == &::google::protobuf::internal::kEmptyString) {
    skill_ = new ::std::string;
  }
  return skill_;
}
inline ::std::string* PlayerInfo::release_skill() {
  clear_has_skill();
  if (skill_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = skill_;
    skill_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerInfo::set_allocated_skill(::std::string* skill) {
  if (skill_ != &::google::protobuf::internal::kEmptyString) {
    delete skill_;
  }
  if (skill) {
    set_has_skill();
    skill_ = skill;
  } else {
    clear_has_skill();
    skill_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 accountid = 6;
inline bool PlayerInfo::has_accountid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerInfo::set_has_accountid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerInfo::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerInfo::clear_accountid() {
  accountid_ = 0u;
  clear_has_accountid();
}
inline ::google::protobuf::uint32 PlayerInfo::accountid() const {
  return accountid_;
}
inline void PlayerInfo::set_accountid(::google::protobuf::uint32 value) {
  set_has_accountid();
  accountid_ = value;
}

// optional float style = 7;
inline bool PlayerInfo::has_style() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerInfo::set_has_style() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerInfo::clear_has_style() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerInfo::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline float PlayerInfo::style() const {
  return style_;
}
inline void PlayerInfo::set_style(float value) {
  set_has_style();
  style_ = value;
}

// optional float total_style = 8;
inline bool PlayerInfo::has_total_style() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerInfo::set_has_total_style() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerInfo::clear_has_total_style() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerInfo::clear_total_style() {
  total_style_ = 0;
  clear_has_total_style();
}
inline float PlayerInfo::total_style() const {
  return total_style_;
}
inline void PlayerInfo::set_total_style(float value) {
  set_has_total_style();
  total_style_ = value;
}

// optional uint32 kills = 9;
inline bool PlayerInfo::has_kills() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlayerInfo::set_has_kills() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlayerInfo::clear_has_kills() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlayerInfo::clear_kills() {
  kills_ = 0u;
  clear_has_kills();
}
inline ::google::protobuf::uint32 PlayerInfo::kills() const {
  return kills_;
}
inline void PlayerInfo::set_kills(::google::protobuf::uint32 value) {
  set_has_kills();
  kills_ = value;
}

// optional uint32 deaths = 10;
inline bool PlayerInfo::has_deaths() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PlayerInfo::set_has_deaths() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PlayerInfo::clear_has_deaths() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PlayerInfo::clear_deaths() {
  deaths_ = 0u;
  clear_has_deaths();
}
inline ::google::protobuf::uint32 PlayerInfo::deaths() const {
  return deaths_;
}
inline void PlayerInfo::set_deaths(::google::protobuf::uint32 value) {
  set_has_deaths();
  deaths_ = value;
}

// optional uint32 waypoint = 11;
inline bool PlayerInfo::has_waypoint() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PlayerInfo::set_has_waypoint() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PlayerInfo::clear_has_waypoint() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PlayerInfo::clear_waypoint() {
  waypoint_ = 0u;
  clear_has_waypoint();
}
inline ::google::protobuf::uint32 PlayerInfo::waypoint() const {
  return waypoint_;
}
inline void PlayerInfo::set_waypoint(::google::protobuf::uint32 value) {
  set_has_waypoint();
  waypoint_ = value;
}

// optional .da.protobuf.Vector objective_position = 12;
inline bool PlayerInfo::has_objective_position() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PlayerInfo::set_has_objective_position() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PlayerInfo::clear_has_objective_position() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PlayerInfo::clear_objective_position() {
  if (objective_position_ != NULL) objective_position_->::da::protobuf::Vector::Clear();
  clear_has_objective_position();
}
inline const ::da::protobuf::Vector& PlayerInfo::objective_position() const {
  return objective_position_ != NULL ? *objective_position_ : *default_instance_->objective_position_;
}
inline ::da::protobuf::Vector* PlayerInfo::mutable_objective_position() {
  set_has_objective_position();
  if (objective_position_ == NULL) objective_position_ = new ::da::protobuf::Vector;
  return objective_position_;
}
inline ::da::protobuf::Vector* PlayerInfo::release_objective_position() {
  clear_has_objective_position();
  ::da::protobuf::Vector* temp = objective_position_;
  objective_position_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_objective_position(::da::protobuf::Vector* objective_position) {
  delete objective_position_;
  objective_position_ = objective_position;
  if (objective_position) {
    set_has_objective_position();
  } else {
    clear_has_objective_position();
  }
}

// optional string slowmo_type = 13;
inline bool PlayerInfo::has_slowmo_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PlayerInfo::set_has_slowmo_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PlayerInfo::clear_has_slowmo_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PlayerInfo::clear_slowmo_type() {
  if (slowmo_type_ != &::google::protobuf::internal::kEmptyString) {
    slowmo_type_->clear();
  }
  clear_has_slowmo_type();
}
inline const ::std::string& PlayerInfo::slowmo_type() const {
  return *slowmo_type_;
}
inline void PlayerInfo::set_slowmo_type(const ::std::string& value) {
  set_has_slowmo_type();
  if (slowmo_type_ == &::google::protobuf::internal::kEmptyString) {
    slowmo_type_ = new ::std::string;
  }
  slowmo_type_->assign(value);
}
inline void PlayerInfo::set_slowmo_type(const char* value) {
  set_has_slowmo_type();
  if (slowmo_type_ == &::google::protobuf::internal::kEmptyString) {
    slowmo_type_ = new ::std::string;
  }
  slowmo_type_->assign(value);
}
inline void PlayerInfo::set_slowmo_type(const char* value, size_t size) {
  set_has_slowmo_type();
  if (slowmo_type_ == &::google::protobuf::internal::kEmptyString) {
    slowmo_type_ = new ::std::string;
  }
  slowmo_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerInfo::mutable_slowmo_type() {
  set_has_slowmo_type();
  if (slowmo_type_ == &::google::protobuf::internal::kEmptyString) {
    slowmo_type_ = new ::std::string;
  }
  return slowmo_type_;
}
inline ::std::string* PlayerInfo::release_slowmo_type() {
  clear_has_slowmo_type();
  if (slowmo_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = slowmo_type_;
    slowmo_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerInfo::set_allocated_slowmo_type(::std::string* slowmo_type) {
  if (slowmo_type_ != &::google::protobuf::internal::kEmptyString) {
    delete slowmo_type_;
  }
  if (slowmo_type) {
    set_has_slowmo_type();
    slowmo_type_ = slowmo_type;
  } else {
    clear_has_slowmo_type();
    slowmo_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float slowmo_seconds = 14;
inline bool PlayerInfo::has_slowmo_seconds() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PlayerInfo::set_has_slowmo_seconds() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PlayerInfo::clear_has_slowmo_seconds() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PlayerInfo::clear_slowmo_seconds() {
  slowmo_seconds_ = 0;
  clear_has_slowmo_seconds();
}
inline float PlayerInfo::slowmo_seconds() const {
  return slowmo_seconds_;
}
inline void PlayerInfo::set_slowmo_seconds(float value) {
  set_has_slowmo_seconds();
  slowmo_seconds_ = value;
}

// -------------------------------------------------------------------

// KillInfo

// optional .da.protobuf.PlayerInfo victim = 1;
inline bool KillInfo::has_victim() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KillInfo::set_has_victim() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KillInfo::clear_has_victim() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KillInfo::clear_victim() {
  if (victim_ != NULL) victim_->::da::protobuf::PlayerInfo::Clear();
  clear_has_victim();
}
inline const ::da::protobuf::PlayerInfo& KillInfo::victim() const {
  return victim_ != NULL ? *victim_ : *default_instance_->victim_;
}
inline ::da::protobuf::PlayerInfo* KillInfo::mutable_victim() {
  set_has_victim();
  if (victim_ == NULL) victim_ = new ::da::protobuf::PlayerInfo;
  return victim_;
}
inline ::da::protobuf::PlayerInfo* KillInfo::release_victim() {
  clear_has_victim();
  ::da::protobuf::PlayerInfo* temp = victim_;
  victim_ = NULL;
  return temp;
}
inline void KillInfo::set_allocated_victim(::da::protobuf::PlayerInfo* victim) {
  delete victim_;
  victim_ = victim;
  if (victim) {
    set_has_victim();
  } else {
    clear_has_victim();
  }
}

// optional .da.protobuf.PlayerInfo killer = 2;
inline bool KillInfo::has_killer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KillInfo::set_has_killer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KillInfo::clear_has_killer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KillInfo::clear_killer() {
  if (killer_ != NULL) killer_->::da::protobuf::PlayerInfo::Clear();
  clear_has_killer();
}
inline const ::da::protobuf::PlayerInfo& KillInfo::killer() const {
  return killer_ != NULL ? *killer_ : *default_instance_->killer_;
}
inline ::da::protobuf::PlayerInfo* KillInfo::mutable_killer() {
  set_has_killer();
  if (killer_ == NULL) killer_ = new ::da::protobuf::PlayerInfo;
  return killer_;
}
inline ::da::protobuf::PlayerInfo* KillInfo::release_killer() {
  clear_has_killer();
  ::da::protobuf::PlayerInfo* temp = killer_;
  killer_ = NULL;
  return temp;
}
inline void KillInfo::set_allocated_killer(::da::protobuf::PlayerInfo* killer) {
  delete killer_;
  killer_ = killer;
  if (killer) {
    set_has_killer();
  } else {
    clear_has_killer();
  }
}

// optional .da.protobuf.Vector grenade_position = 3;
inline bool KillInfo::has_grenade_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KillInfo::set_has_grenade_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KillInfo::clear_has_grenade_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KillInfo::clear_grenade_position() {
  if (grenade_position_ != NULL) grenade_position_->::da::protobuf::Vector::Clear();
  clear_has_grenade_position();
}
inline const ::da::protobuf::Vector& KillInfo::grenade_position() const {
  return grenade_position_ != NULL ? *grenade_position_ : *default_instance_->grenade_position_;
}
inline ::da::protobuf::Vector* KillInfo::mutable_grenade_position() {
  set_has_grenade_position();
  if (grenade_position_ == NULL) grenade_position_ = new ::da::protobuf::Vector;
  return grenade_position_;
}
inline ::da::protobuf::Vector* KillInfo::release_grenade_position() {
  clear_has_grenade_position();
  ::da::protobuf::Vector* temp = grenade_position_;
  grenade_position_ = NULL;
  return temp;
}
inline void KillInfo::set_allocated_grenade_position(::da::protobuf::Vector* grenade_position) {
  delete grenade_position_;
  grenade_position_ = grenade_position;
  if (grenade_position) {
    set_has_grenade_position();
  } else {
    clear_has_grenade_position();
  }
}

// -------------------------------------------------------------------

// PlayerList

// optional int32 accountid = 1;
inline bool PlayerList::has_accountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerList::set_has_accountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerList::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerList::clear_accountid() {
  accountid_ = 0;
  clear_has_accountid();
}
inline ::google::protobuf::int32 PlayerList::accountid() const {
  return accountid_;
}
inline void PlayerList::set_accountid(::google::protobuf::int32 value) {
  set_has_accountid();
  accountid_ = value;
}

// optional string name = 2;
inline bool PlayerList::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerList::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerList::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerList::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlayerList::name() const {
  return *name_;
}
inline void PlayerList::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayerList::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayerList::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerList::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PlayerList::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerList::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float style = 3;
inline bool PlayerList::has_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerList::set_has_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerList::clear_has_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerList::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline float PlayerList::style() const {
  return style_;
}
inline void PlayerList::set_style(float value) {
  set_has_style();
  style_ = value;
}

// -------------------------------------------------------------------

// ServerReply

// optional string daily_leader = 1;
inline bool ServerReply::has_daily_leader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerReply::set_has_daily_leader() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerReply::clear_has_daily_leader() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerReply::clear_daily_leader() {
  if (daily_leader_ != &::google::protobuf::internal::kEmptyString) {
    daily_leader_->clear();
  }
  clear_has_daily_leader();
}
inline const ::std::string& ServerReply::daily_leader() const {
  return *daily_leader_;
}
inline void ServerReply::set_daily_leader(const ::std::string& value) {
  set_has_daily_leader();
  if (daily_leader_ == &::google::protobuf::internal::kEmptyString) {
    daily_leader_ = new ::std::string;
  }
  daily_leader_->assign(value);
}
inline void ServerReply::set_daily_leader(const char* value) {
  set_has_daily_leader();
  if (daily_leader_ == &::google::protobuf::internal::kEmptyString) {
    daily_leader_ = new ::std::string;
  }
  daily_leader_->assign(value);
}
inline void ServerReply::set_daily_leader(const char* value, size_t size) {
  set_has_daily_leader();
  if (daily_leader_ == &::google::protobuf::internal::kEmptyString) {
    daily_leader_ = new ::std::string;
  }
  daily_leader_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerReply::mutable_daily_leader() {
  set_has_daily_leader();
  if (daily_leader_ == &::google::protobuf::internal::kEmptyString) {
    daily_leader_ = new ::std::string;
  }
  return daily_leader_;
}
inline ::std::string* ServerReply::release_daily_leader() {
  clear_has_daily_leader();
  if (daily_leader_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = daily_leader_;
    daily_leader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerReply::set_allocated_daily_leader(::std::string* daily_leader) {
  if (daily_leader_ != &::google::protobuf::internal::kEmptyString) {
    delete daily_leader_;
  }
  if (daily_leader) {
    set_has_daily_leader();
    daily_leader_ = daily_leader;
  } else {
    clear_has_daily_leader();
    daily_leader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float daily_leader_style = 2;
inline bool ServerReply::has_daily_leader_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerReply::set_has_daily_leader_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerReply::clear_has_daily_leader_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerReply::clear_daily_leader_style() {
  daily_leader_style_ = 0;
  clear_has_daily_leader_style();
}
inline float ServerReply::daily_leader_style() const {
  return daily_leader_style_;
}
inline void ServerReply::set_daily_leader_style(float value) {
  set_has_daily_leader_style();
  daily_leader_style_ = value;
}

// optional string weekly_leader = 3;
inline bool ServerReply::has_weekly_leader() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerReply::set_has_weekly_leader() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerReply::clear_has_weekly_leader() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerReply::clear_weekly_leader() {
  if (weekly_leader_ != &::google::protobuf::internal::kEmptyString) {
    weekly_leader_->clear();
  }
  clear_has_weekly_leader();
}
inline const ::std::string& ServerReply::weekly_leader() const {
  return *weekly_leader_;
}
inline void ServerReply::set_weekly_leader(const ::std::string& value) {
  set_has_weekly_leader();
  if (weekly_leader_ == &::google::protobuf::internal::kEmptyString) {
    weekly_leader_ = new ::std::string;
  }
  weekly_leader_->assign(value);
}
inline void ServerReply::set_weekly_leader(const char* value) {
  set_has_weekly_leader();
  if (weekly_leader_ == &::google::protobuf::internal::kEmptyString) {
    weekly_leader_ = new ::std::string;
  }
  weekly_leader_->assign(value);
}
inline void ServerReply::set_weekly_leader(const char* value, size_t size) {
  set_has_weekly_leader();
  if (weekly_leader_ == &::google::protobuf::internal::kEmptyString) {
    weekly_leader_ = new ::std::string;
  }
  weekly_leader_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerReply::mutable_weekly_leader() {
  set_has_weekly_leader();
  if (weekly_leader_ == &::google::protobuf::internal::kEmptyString) {
    weekly_leader_ = new ::std::string;
  }
  return weekly_leader_;
}
inline ::std::string* ServerReply::release_weekly_leader() {
  clear_has_weekly_leader();
  if (weekly_leader_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weekly_leader_;
    weekly_leader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerReply::set_allocated_weekly_leader(::std::string* weekly_leader) {
  if (weekly_leader_ != &::google::protobuf::internal::kEmptyString) {
    delete weekly_leader_;
  }
  if (weekly_leader) {
    set_has_weekly_leader();
    weekly_leader_ = weekly_leader;
  } else {
    clear_has_weekly_leader();
    weekly_leader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float weekly_leader_style = 4;
inline bool ServerReply::has_weekly_leader_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerReply::set_has_weekly_leader_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerReply::clear_has_weekly_leader_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerReply::clear_weekly_leader_style() {
  weekly_leader_style_ = 0;
  clear_has_weekly_leader_style();
}
inline float ServerReply::weekly_leader_style() const {
  return weekly_leader_style_;
}
inline void ServerReply::set_weekly_leader_style(float value) {
  set_has_weekly_leader_style();
  weekly_leader_style_ = value;
}

// optional string monthly_leader = 5;
inline bool ServerReply::has_monthly_leader() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerReply::set_has_monthly_leader() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerReply::clear_has_monthly_leader() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerReply::clear_monthly_leader() {
  if (monthly_leader_ != &::google::protobuf::internal::kEmptyString) {
    monthly_leader_->clear();
  }
  clear_has_monthly_leader();
}
inline const ::std::string& ServerReply::monthly_leader() const {
  return *monthly_leader_;
}
inline void ServerReply::set_monthly_leader(const ::std::string& value) {
  set_has_monthly_leader();
  if (monthly_leader_ == &::google::protobuf::internal::kEmptyString) {
    monthly_leader_ = new ::std::string;
  }
  monthly_leader_->assign(value);
}
inline void ServerReply::set_monthly_leader(const char* value) {
  set_has_monthly_leader();
  if (monthly_leader_ == &::google::protobuf::internal::kEmptyString) {
    monthly_leader_ = new ::std::string;
  }
  monthly_leader_->assign(value);
}
inline void ServerReply::set_monthly_leader(const char* value, size_t size) {
  set_has_monthly_leader();
  if (monthly_leader_ == &::google::protobuf::internal::kEmptyString) {
    monthly_leader_ = new ::std::string;
  }
  monthly_leader_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerReply::mutable_monthly_leader() {
  set_has_monthly_leader();
  if (monthly_leader_ == &::google::protobuf::internal::kEmptyString) {
    monthly_leader_ = new ::std::string;
  }
  return monthly_leader_;
}
inline ::std::string* ServerReply::release_monthly_leader() {
  clear_has_monthly_leader();
  if (monthly_leader_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = monthly_leader_;
    monthly_leader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerReply::set_allocated_monthly_leader(::std::string* monthly_leader) {
  if (monthly_leader_ != &::google::protobuf::internal::kEmptyString) {
    delete monthly_leader_;
  }
  if (monthly_leader) {
    set_has_monthly_leader();
    monthly_leader_ = monthly_leader;
  } else {
    clear_has_monthly_leader();
    monthly_leader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float monthly_leader_style = 6;
inline bool ServerReply::has_monthly_leader_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerReply::set_has_monthly_leader_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerReply::clear_has_monthly_leader_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerReply::clear_monthly_leader_style() {
  monthly_leader_style_ = 0;
  clear_has_monthly_leader_style();
}
inline float ServerReply::monthly_leader_style() const {
  return monthly_leader_style_;
}
inline void ServerReply::set_monthly_leader_style(float value) {
  set_has_monthly_leader_style();
  monthly_leader_style_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace da

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::da::protobuf::KillFlags>() {
  return ::da::protobuf::KillFlags_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_data_2eproto__INCLUDED
